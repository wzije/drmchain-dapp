// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

// import "./Signature.sol";
import "./Ownable.sol";

contract Publication is Ownable {
    string public title;
    string public author;
    address public author_account;
    string public publisher;
    string public releaseDate;
    string public isbn;
    string public cover;
    string public description;

    //hash yang sudah di sign dan encrypt, hanya bisa dibuka dengan kunci private owner
    string private documentHash;

    //customer struct
    struct RequestOwner {
        address customer;
        string publicKey;
        uint256 status; //1:request, 2:accepted, 3:rejected
        uint256 date;
    }

    //couple variable
    address[] private requestAccounts;
    mapping(address => RequestOwner) requests;

    event Requested(address customer, string title);
    event RequestAccepted(address customer, string title, uint256 status);

    constructor(
        string memory _title,
        string memory _author,
        address _author_account,
        string memory _publisher,
        string memory _releaseDate,
        string memory _isbn,
        string memory _cover,
        string memory _description,
        string memory _hashDocument,
        address _owner
    ) {
        title = _title;
        author = _author;
        author_account = _author_account;
        publisher = _publisher;
        releaseDate = _releaseDate;
        isbn = _isbn;
        cover = _cover;
        description = _description;
        documentHash = _hashDocument;

        _transferOwnership(_owner);
    }

    function getDocument() external view onlyOwner returns (string memory) {
        return documentHash;
    }

    function requestOwner(string memory _customerPublicKey) external nonOwner {
        require(requests[msg.sender].status != 1, "you requested");

        for (uint256 i = 0; i < requestAccounts.length; i++) {
            address _customer = requestAccounts[i];
            RequestOwner storage r = requests[_customer];
            require(r.status != 1, "the book was booked");
        }

        RequestOwner memory request = RequestOwner({
            customer: msg.sender,
            publicKey: _customerPublicKey,
            status: 1,
            date: block.timestamp
        });

        requests[msg.sender] = request;
        requestAccounts.push(msg.sender);

        //emit event
        emit Requested(msg.sender, title);
    }

    function getRequest()
        external
        view
        onlyOwner
        returns (address _addr, string memory _publicKey)
    {
        uint256 count = requestAccounts.length;

        for (uint256 i = 0; i < count; i++) {
            address _customer = requestAccounts[i];
            RequestOwner storage request = requests[_customer];
            if (request.status == 1) {
                _addr = request.customer;
                _publicKey = request.publicKey;
            }
        }

        return (_addr, _publicKey);
    }

    // _hashDocument is new hash after re sign with new owner
    function acceptRequest(
        address _customer,
        bool _isAccepted,
        string memory _hashDocument
    ) external onlyOwner {
        require(
            requests[_customer].status == 1,
            "the request is not available"
        );

        uint256 status;

        if (_isAccepted) {
            status = 2;
            documentHash = _hashDocument;
            _transferOwnership(_customer);
        } else {
            status = 3;
        }

        requests[_customer].status = status;
        emit RequestAccepted(_customer, title, status);
    }
}
